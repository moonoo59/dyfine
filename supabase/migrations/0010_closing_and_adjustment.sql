-- =============================================================
-- F5 월 마감(Closing) 기능 — 조정 전표 연결 테이블 + RPC
-- =============================================================

-- 1. adjustment_links 테이블 (조정 전표 ↔ 원본 전표 연결)
CREATE TABLE IF NOT EXISTS adjustment_links (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    original_entry_id bigint REFERENCES transaction_entries(id) ON DELETE CASCADE,
    adjustment_entry_id bigint REFERENCES transaction_entries(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    UNIQUE(original_entry_id, adjustment_entry_id)
);

ALTER TABLE adjustment_links ENABLE ROW LEVEL SECURITY;

-- RLS 정책: household_members 기반 접근 제어
-- adjustment_links는 transaction_entries를 통해 간접적으로 household가 결정되므로
-- entry 소유 가구의 멤버만 접근 가능
DROP POLICY IF EXISTS "Members can manage adjustment_links" ON adjustment_links;
CREATE POLICY "Members can manage adjustment_links"
    ON adjustment_links FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM transaction_entries te
            JOIN household_members hm ON hm.household_id = te.household_id
            WHERE te.id = adjustment_links.original_entry_id
              AND hm.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM transaction_entries te
            JOIN household_members hm ON hm.household_id = te.household_id
            WHERE te.id = adjustment_links.original_entry_id
              AND hm.user_id = auth.uid()
        )
    );

-- =============================================================
-- 2. close_month RPC 함수
-- 하나의 트랜잭션 내에서:
--   (1) 미확인 자동이체 건수 확인 (경고용 데이터 반환)
--   (2) 해당 월 전표 is_locked = true
--   (3) 월 요약 스냅샷 JSON 생성
--   (4) month_closings 레코드 INSERT
-- =============================================================

CREATE OR REPLACE FUNCTION close_month(
    p_year_month CHAR(7),      -- 마감 대상 월 (예: '2026-02')
    p_user_id UUID              -- 마감 실행 사용자 ID
)
RETURNS JSONB                   -- 마감 요약 결과 반환
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_household_id UUID;
    v_already_closed BOOLEAN;
    v_start_date TIMESTAMPTZ;
    v_end_date TIMESTAMPTZ;
    v_total_income NUMERIC(18,2) := 0;
    v_total_expense NUMERIC(18,2) := 0;
    v_total_transfer NUMERIC(18,2) := 0;
    v_entry_count INT := 0;
    v_locked_count INT := 0;
    v_pending_transfers INT := 0;
    v_summary JSONB;
BEGIN
    -- 1. 사용자의 household_id 조회
    SELECT household_id INTO v_household_id
    FROM household_members
    WHERE user_id = p_user_id
    LIMIT 1;

    IF v_household_id IS NULL THEN
        RAISE EXCEPTION '사용자의 가구 정보를 찾을 수 없습니다.';
    END IF;

    -- 2. 이미 마감되었는지 확인
    SELECT EXISTS(
        SELECT 1 FROM month_closings
        WHERE household_id = v_household_id AND year_month = p_year_month
    ) INTO v_already_closed;

    IF v_already_closed THEN
        RAISE EXCEPTION '해당 월(%)은 이미 마감되었습니다.', p_year_month;
    END IF;

    -- 3. 월 범위 계산
    v_start_date := (p_year_month || '-01')::DATE;
    v_end_date := (v_start_date + INTERVAL '1 month' - INTERVAL '1 second');

    -- 4. 미확인 자동이체 건수 (경고용)
    SELECT COUNT(*) INTO v_pending_transfers
    FROM auto_transfer_instances
    WHERE household_id = v_household_id
      AND status = 'pending'
      AND due_date >= v_start_date::DATE
      AND due_date <= v_end_date::DATE;

    -- 5. 해당 월 전표 통계 및 락 처리
    -- 5-1. 전표 건수
    SELECT COUNT(*) INTO v_entry_count
    FROM transaction_entries
    WHERE household_id = v_household_id
      AND occurred_at >= v_start_date
      AND occurred_at <= v_end_date;

    -- 5-2. 수입 합산
    SELECT COALESCE(SUM(tl.amount), 0) INTO v_total_income
    FROM transaction_entries te
    JOIN transaction_lines tl ON tl.entry_id = te.id
    WHERE te.household_id = v_household_id
      AND te.entry_type = 'income'
      AND te.occurred_at >= v_start_date
      AND te.occurred_at <= v_end_date
      AND tl.amount > 0;

    -- 5-3. 지출 합산 (음수 라인의 절대값)
    SELECT COALESCE(SUM(ABS(tl.amount)), 0) INTO v_total_expense
    FROM transaction_entries te
    JOIN transaction_lines tl ON tl.entry_id = te.id
    WHERE te.household_id = v_household_id
      AND te.entry_type = 'expense'
      AND te.occurred_at >= v_start_date
      AND te.occurred_at <= v_end_date
      AND tl.amount < 0;

    -- 5-4. 이체 합산 (양수 라인 기준)
    SELECT COALESCE(SUM(tl.amount), 0) INTO v_total_transfer
    FROM transaction_entries te
    JOIN transaction_lines tl ON tl.entry_id = te.id
    WHERE te.household_id = v_household_id
      AND te.entry_type = 'transfer'
      AND te.occurred_at >= v_start_date
      AND te.occurred_at <= v_end_date
      AND tl.amount > 0;

    -- 6. 전표 락 처리 (is_locked = true)
    UPDATE transaction_entries
    SET is_locked = true
    WHERE household_id = v_household_id
      AND occurred_at >= v_start_date
      AND occurred_at <= v_end_date
      AND is_locked = false;

    GET DIAGNOSTICS v_locked_count = ROW_COUNT;

    -- 7. 요약 JSON 구성
    v_summary := jsonb_build_object(
        'year_month', p_year_month,
        'total_income', v_total_income,
        'total_expense', v_total_expense,
        'total_transfer', v_total_transfer,
        'net_change', v_total_income - v_total_expense,
        'entry_count', v_entry_count,
        'locked_count', v_locked_count,
        'pending_transfers', v_pending_transfers,
        'closed_at', NOW()
    );

    -- 8. month_closings 레코드 INSERT
    INSERT INTO month_closings (household_id, year_month, closed_at, closed_by, summary_json)
    VALUES (v_household_id, p_year_month, NOW(), p_user_id, v_summary);

    -- 결과 반환
    RETURN v_summary;
END;
$$;
